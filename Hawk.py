from __future__ import print_function
from requests import session
from requests.utils import quote
import json
from datetime import timedelta, date, datetime
import calendar
import os
import pytz

from googleapiclient.discovery import build
from httplib2 import Http
from oauth2client import file, client, tools

# Youfit login
USERNAME = os.environ['USERNAME']
PASSWORD = os.environ['PASSWORD']

# Offset of the current week (can be used to run for next week or 3 weeks back - if needed)
OFFSET = int(os.environ['OFFSET']) if 'OFFSET' in os.environ else 0

# Timezone and Pytz object
TIMEZONE = os.environ['TIMEZONE'] if 'TIMEZONE' in os.environ else 'America/New_York'
PY_TIMEZONE = pytz.timezone(TIMEZONE)

# Default event description
EVENT_DESCRIPTION = 'Autogenerated Youfit event'


def get_last_or_next_day(cal_day, backwards, week_offset=0):
    """
    Method to find the next calendar.(MONDAY/TUESDAY/WEDNESDAY...etc) in the week
    :param cal_day:
    :param backwards: Will search forwards/backwards in the week
    :param week_offset: The offset of the current week we want to search (default is today / this week)
    :return:
    """
    # Iterator of the current day we're holding (plus/minus the week offset)
    last_day = date.today() + timedelta(weeks=week_offset)
    # Static one-day variable datetime
    one_day = timedelta(days=1)

    # While iterator isn't the day we're looking for..
    while last_day.weekday() != cal_day:
        # Search back through time
        if backwards:
            last_day -= one_day
        # Search forward through time
        else:
            last_day += one_day
    # Return the iterator
    return last_day


def build_calendar_service():
    # Setup the Calendar API
    SCOPES = 'https://www.googleapis.com/auth/calendar'
    store = file.Storage('token.json')
    creds = store.get()
    if not creds or creds.invalid:
        flow = client.flow_from_clientsecrets('credentials.json', SCOPES)
        creds = tools.run_flow(flow, store)
    return build('calendar', 'v3', http=creds.authorize(Http()))  # service


def get_json_schedule(from_date, to_date):
    """
    Get the Youfit schedule JSON payload for the week
    :return:
    """

    # Create a new session
    session_requests = session()

    # Request the signin page for Youfit
    signin_page_result = session_requests.get('https://mico.myiclubonline.com/iclub/members/signin.htm')

    # Try to sign in
    member_page = session_requests.post('https://mico.myiclubonline.com/iclub/j_spring_security_check',
                                        data={'j_username': USERNAME, 'j_password': PASSWORD})
    # Go-to the member activity page
    member_page_2 = session_requests.get('https://mico.myiclubonline.com/iclub/members')

    # Get the json data from the current/next week
    json_result = session_requests.get(
        'https://mico.myiclubonline.com/iclub/scheduling/memberSchedule.htm?lowDate={}&highDate={}&_=1532035883769'.format(
            quote(from_date.strftime('%m/%d/%Y'), safe=''),
            quote(to_date.strftime('%m/%d/%Y'), safe='')
        )
    )

    # Load in the JSON response
    try:
        member_schedule_json = json.loads(json_result.text)
    except json.JSONDecodeError:
        print("Unable to decode JSON output!")
        exit(1)

    if len(member_schedule_json) == 0:
        print("Nothing found for the week of {} to {}, try again later!".format(from_date, to_date))
        exit(1)

    # Print out the information found about each event, date, and time
    for apt in member_schedule_json:
        print("You have an appointment with {} on {} at {} - {}".format(apt['employeeName'],
                                                                        apt['eventDate'],
                                                                        apt['eventStartTime'],
                                                                        apt['eventEndTime']))

    return member_schedule_json


def add_schedule_to_calendar(service, payload):
    """
    Given a JSON payload from Youfit, and the Google Calendar service, add each event to the calendar
    :param service:
    :param payload:
    :return:
    """

    for apt in payload:
        start_time_dt = datetime.strptime("{} {}".format(apt['eventDate'], apt['eventStartTime']), '%m/%d/%Y %I:%M %p')
        end_time_dt = datetime.strptime("{} {}".format(apt['eventDate'], apt['eventEndTime']), '%m/%d/%Y %I:%M %p')
        start_time = PY_TIMEZONE.localize(start_time_dt).isoformat()
        end_time = PY_TIMEZONE.localize(end_time_dt).isoformat()

        event = {
            'summary': 'Trainer Session with ' + apt['employeeName'].split(' ')[0],
            'description': EVENT_DESCRIPTION,
            'start': {
                'dateTime': start_time,
                'timeZone': TIMEZONE,
            },
            'end': {
                'dateTime': end_time,
                'timeZone': TIMEZONE,
            },
            "reminders": {
                "useDefault": True
            }
        }

        # event_check = {
        #     'timeMin': start_time,
        #     'timeMax': end_time,
        #     'timeZone': timezone,
        #     'items': [
        #         {
        #             "id": 'primary'
        #         }
        #     ]
        # }
        # Check if event is already in calendar
        # freebusy_query_result = service.freebusy().query(body=event_check).execute()
        # if len(freebusy_query_result['calendars']['primary']['busy']) > 0:
        #     # Skip if event already in calendar
        #     print("Event skipped {} - {}!".format(start_time, end_time))
        #     continue

        # Create an event
        event_created_result = service.events().insert(calendarId='primary', body=event).execute()
        print('Event created: %s' % (event_created_result.get('htmlLink')))


def delete_existing_calendar_events(service, to_date):
    to_datetime = datetime.combine(to_date, datetime.max.time())
    to_datetime.replace(tzinfo=PY_TIMEZONE)

    events = service.events().list(calendarId='primary',
                                   timeMin=datetime.utcnow().isoformat() + 'Z',
                                   timeMax=to_datetime.isoformat() + '+00:00',
                                   timeZone=TIMEZONE).execute()
    for event in events['items']:
        if 'description' in event and event['description'] == EVENT_DESCRIPTION:
            service.events().delete(calendarId='primary',
                                    eventId=event['id']).execute()
            print("Deleted event with id: {}".format(event['id']))


def hawk():
    """
    Main method
    :return:
    """
    # Calculate the last saturday and next sunday of the week
    last_sun = get_last_or_next_day(calendar.SUNDAY, backwards=True, week_offset=OFFSET)
    next_sat = get_last_or_next_day(calendar.SATURDAY, backwards=False, week_offset=OFFSET)

    payload = get_json_schedule(last_sun, next_sat)
    service = build_calendar_service()
    delete_existing_calendar_events(service, next_sat)
    add_schedule_to_calendar(service, payload)


if __name__ == '__main__':
    hawk()
