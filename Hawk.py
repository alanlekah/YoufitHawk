from __future__ import print_function
from requests import session
from requests.utils import quote
import json
from datetime import timedelta, date, datetime
import calendar
import os
import pytz

from googleapiclient.discovery import build
from httplib2 import Http
from oauth2client import file, client, tools

# Youfit login
USERNAME = os.environ['USERNAME']
PASSWORD = os.environ['PASSWORD']

# Offset of the current week (can be used to run for next week or 3 weeks back - if needed)
OFFSET = int(os.environ['OFFSET']) if 'OFFSET' in os.environ else 0

# Timezone and Pytz object
TIMEZONE = os.environ['TIMEZONE'] if 'TIMEZONE' in os.environ else 'America/New_York'
PY_TIMEZONE = pytz.timezone(TIMEZONE)

# Default event description
EVENT_DESCRIPTION = 'Autogenerated Youfit event'


def get_last_or_next_day(cal_day, backwards, week_offset=0):
    """
    Method to find the next calendar.(MONDAY/TUESDAY/WEDNESDAY...etc) in the week
    :param cal_day:
    :param backwards: Will search forwards/backwards in the week
    :param week_offset: The offset of the current week we want to search (default is today / this week)
    :return:
    """
    # Iterator of the current day we're holding (plus/minus the week offset)
    last_day = date.today() + timedelta(weeks=week_offset)
    # Static one-day variable datetime
    one_day = timedelta(days=1)

    # While iterator isn't the day we're looking for..
    while last_day.weekday() != cal_day:
        # Search back through time
        if backwards:
            last_day -= one_day
        # Search forward through time
        else:
            last_day += one_day
    # Return the iterator
    return last_day


def build_calendar_service():
    # Setup the Calendar API
    SCOPES = 'https://www.googleapis.com/auth/calendar'
    store = file.Storage('token.json')
    creds = store.get()
    if not creds or creds.invalid:
        flow = client.flow_from_clientsecrets('credentials.json', SCOPES)
        creds = tools.run_flow(flow, store)
    return build('calendar', 'v3', http=creds.authorize(Http()))  # service


def get_json_schedule(from_date, to_date):
    """
    Get the Youfit schedule JSON payload for the week
    :return:
    """

    # Create a new session
    session_requests = session()

    # Request the signin page for Youfit
    signin_page_result = session_requests.get('https://mico.myiclubonline.com/iclub/members/signin.htm')

    # Try to sign in
    member_page = session_requests.post('https://mico.myiclubonline.com/iclub/j_spring_security_check',
                                        data={'j_username': USERNAME, 'j_password': PASSWORD})
    # Go-to the member activity page
    member_page_2 = session_requests.get('https://mico.myiclubonline.com/iclub/members')

    # Get the json data from the current/next week
    json_result = session_requests.get(
        'https://mico.myiclubonline.com/iclub/scheduling/memberSchedule.htm?lowDate={}&highDate={}&_=1532035883769'.format(
            quote(from_date.strftime('%m/%d/%Y'), safe=''),
            quote(to_date.strftime('%m/%d/%Y'), safe='')
        )
    )

    # Load in the JSON response
    try:
        member_schedule_json = json.loads(json_result.text)
    except json.JSONDecodeError:
        print("Unable to decode JSON output!")
        exit(1)

    if len(member_schedule_json) == 0:
        print("Nothing found for the week of {} to {}, try again later!".format(from_date, to_date))
        exit(1)

    # Print out the information found about each event, date, and time
    for apt in member_schedule_json:
        print("You have an appointment with {} on {} at {} - {}".format(apt['employeeName'],
                                                                        apt['eventDate'],
                                                                        apt['eventStartTime'],
                                                                        apt['eventEndTime']))

    return member_schedule_json


def add_schedule_to_calendar(service, payload, events):
    """
    Given a JSON payload from Youfit, and the Google Calendar service, add each event to the calendar
    :param service:
    :param payload:
    :return:
    """

    for apt in payload:
        start_time_dt = datetime.strptime("{} {}".format(apt['eventDate'], apt['eventStartTime']), '%m/%d/%Y %I:%M %p')
        end_time_dt = datetime.strptime("{} {}".format(apt['eventDate'], apt['eventEndTime']), '%m/%d/%Y %I:%M %p')
        start_time = PY_TIMEZONE.localize(start_time_dt).isoformat()
        end_time = PY_TIMEZONE.localize(end_time_dt).isoformat()

        if not is_youfit_event_in_google_cal_events(apt, events):
            event = {
                'summary': 'Trainer Session with ' + apt['employeeName'].split(' ')[0],
                'description': EVENT_DESCRIPTION,
                'start': {
                    'dateTime': start_time,
                    'timeZone': TIMEZONE,
                },
                'end': {
                    'dateTime': end_time,
                    'timeZone': TIMEZONE,
                },
                "reminders": {
                    "useDefault": True
                }
            }

            # Create an event
            event_created_result = service.events().insert(calendarId='primary', body=event).execute()
            print('Event created: %s' % (event_created_result.get('htmlLink')))


def is_youfit_event_in_google_cal_events(youfit_event, google_cal_events):
    """
    Given a youfit formatted dict, return true if its found within a list of google calendar events
    :param youfit_event:
    :param google_cal_events:
    :return:
    """
    start_time_dt = datetime.strptime("{} {}".format(youfit_event['eventDate'], youfit_event['eventStartTime']),
                                      '%m/%d/%Y %I:%M %p')
    end_time_dt = datetime.strptime("{} {}".format(youfit_event['eventDate'], youfit_event['eventEndTime']),
                                    '%m/%d/%Y %I:%M %p')
    start_time = PY_TIMEZONE.localize(start_time_dt)
    end_time = PY_TIMEZONE.localize(end_time_dt)

    for google_event in google_cal_events['items']:
        if start_time == datetime.fromisoformat(google_event['start']['dateTime']) and \
                end_time == datetime.fromisoformat(google_event['end']['dateTime']):
            return True

    return False


def is_google_cal_event_in_youfit_events(google_cal_event, list_of_youfit_events):
    """
    Given a google cal formatted dict, return true if its found within a list of youfit dict events
    :param google_cal_event:
    :param list_of_youfit_events:
    :return:
    """
    for youfit_event in list_of_youfit_events:
        start_time_dt = datetime.strptime("{} {}".format(youfit_event['eventDate'], youfit_event['eventStartTime']),
                                          '%m/%d/%Y %I:%M %p')
        end_time_dt = datetime.strptime("{} {}".format(youfit_event['eventDate'], youfit_event['eventEndTime']),
                                        '%m/%d/%Y %I:%M %p')
        start_time = PY_TIMEZONE.localize(start_time_dt)
        end_time = PY_TIMEZONE.localize(end_time_dt)

        if start_time == datetime.fromisoformat(google_cal_event['start']['dateTime']) and \
                end_time == datetime.fromisoformat(google_cal_event['end']['dateTime']):
            return True

    return False


def delete_existing_calendar_events(service, events, payload):
    """
    for the list of google calendar events for the x time period,
    if you see an event that isnt in the list from youfit, delete it
    :param service:
    :param events:
    :param payload:
    :return:
    """
    for event in events['items']:
        if 'description' in event and event['description'] == EVENT_DESCRIPTION:
            if not is_google_cal_event_in_youfit_events(event, payload):
                service.events().delete(calendarId='primary',
                                        eventId=event['id']).execute()
                print("Deleted event with id: {}".format(event['id']))
            else:
                print("Ignored event with id: {}".format(event['htmlLink']))


def get_existing_calendar_events(service, from_date, to_date):
    """
    get google calendar events between a date period of from_date to to_date
    :param service:
    :param from_date:
    :param to_date:
    :return:
    """
    to_datetime = datetime.combine(to_date, datetime.max.time())
    to_datetime.replace(tzinfo=PY_TIMEZONE)

    from_datetime = datetime.combine(from_date, datetime.min.time())
    from_datetime.replace(tzinfo=PY_TIMEZONE)

    return service.events().list(calendarId='primary',
                                 timeMin=from_datetime.isoformat() + '+00:00',
                                 timeMax=to_datetime.isoformat() + '+00:00',
                                 timeZone=TIMEZONE).execute()


def hawk():
    """
    Main method
    :return:
    """
    # Calculate the last saturday and next sunday of the week
    last_sun = get_last_or_next_day(calendar.SUNDAY, backwards=True, week_offset=OFFSET)
    next_sat = get_last_or_next_day(calendar.SATURDAY, backwards=False, week_offset=OFFSET)

    payload = get_json_schedule(last_sun, next_sat)
    service = build_calendar_service()
    existing_events = get_existing_calendar_events(service, last_sun, next_sat)
    delete_existing_calendar_events(service, existing_events, payload)
    add_schedule_to_calendar(service, payload, existing_events)


if __name__ == '__main__':
    hawk()
